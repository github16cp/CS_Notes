<!-- GFM-TOC -->
* [前言](#前言)
* [1. 二维数组中的查找](#1-二维数组中的查找)
* [2. 替换空格](#2-替换空格)
* [3. 从尾到头打印链表](#3-从尾到头打印链表)
* [4. 重建二叉树](#4-重建二叉树)
* [5. 用两个栈实现队列](#5-用两个栈实现队列)
* [6. 旋转数组的最小数字](#6-旋转数组的最小数字)
* [7. 斐波那契数列](#7-斐波那契数列)
* [8. 跳台阶](#8-跳台阶)
* [9. 变态跳台阶](#9-变态跳台阶)
* [10. 矩形覆盖](#10-矩形覆盖)
* [11. 二进制中1的个数](#11-二进制中1的个数)
* [12. 数值的整数次方](#12-数值的整数次方)
* [13. 调整数组顺序使奇数位于偶数前面](#13-调整数组顺序使奇数位于偶数前面)
* [14. 链表中倒数第k个结点](#14-链表中倒数第k个结点)
* [15. 反转链表](#15-反转链表)
* [16. 合并两个排序的链表](#16-合并两个排序的链表)
* [17. 树的子结构](#17-树的子结构)
* [18. 二叉树的镜像](#18-二叉树的镜像)
* [19. 顺时针打印矩阵](#19-顺时针打印矩阵)
* [20. 包含min函数的栈](#20-包含min函数的栈)
* [21. 栈的压入、弹出序列](#21-栈的压入、弹出序列)
* [22. 从上往下打印二叉树](#22-从上往下打印二叉树)
* [23. 二叉搜索树的后序遍历序列](#23-二叉搜索树的后序遍历序列)
* [24. 二叉树中和为某一值的路径](#24-二叉树中和为某一值的路径)
* [25. 复制链表的复制](#25-复制链表的复制)
* [26. 二叉搜索树与双向链表](#26-二叉搜索树与双向链表)
<!-- GFM-TOC -->

# 前言

`无他，唯手熟尔`

# 1. 二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```C++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int row = (int)array.size();
        int col = (int)array[0].size();
        
        if(row == 0 || col == 0)
            return false;
        
        if(target < array[0][0] || target > array[row-1][col-1])
            return false;
        
        for(int i=0;i<row;i++){
            int l = 0,r = col - 1,m;
            while(l <= r){
                m = (l+r)/2;
                if(target == array[i][m])
                    return true;
                else if(target < array[i][m])
                    r = m - 1;
                else
                    l = m + 1;
            }
        }
        
        return false;
    }
};
```

# 2. 替换空格

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```C++
class Solution {
public:
	void replaceSpace(char *str, int length) {
		int count = 0;
		for (int i = 0; i < length; i++) {
			if (str[i] == ' ')
				count++;
		}

		for (int i = length - 1; i >= 0; i--) {
			if (str[i] != ' ') {
				str[i + 2*count] = str[i];
			}
			else {
				count--;
				str[i + 2*count] = '%';
				str[i + 2 * count + 1] = '2';
				str[i + 2 * count + 2] = '0';
			}
		}
	}
};
```

# 3. 从尾到头打印链表

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

```C++
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
	vector<int> printListFromTailToHead(ListNode* head) {
		vector<int> list;
		if (head != NULL) {
			list.insert(list.begin(), head->val);
			if (head->next != NULL) {
				vector<int> tempVal = printListFromTailToHead(head->next);
				if (tempVal.size() > 0)
					list.insert(list.begin(), tempVal.begin(), tempVal.end());
			}
		}
		return list;
	}
};
```

# 4. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/**
* Definition for binary tree */
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	TreeNode * reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		int vin_len = vin.size();
		if (vin_len == 0)
			return NULL;

		vector<int> pre_left, pre_right, vin_left, vin_right;

		TreeNode *root = new TreeNode(pre[0]);

		int root_index = 0;
		for (int i = 0; i < vin_len; i++) {
			if (vin[i] == root->val) {
				root_index = i;
				break;
			}
		}
		//构建左子树
		for (int i = 0; i < root_index; i++) {
			vin_left.push_back(vin[i]);
			pre_left.push_back(pre[i + 1]);
		}
		//构建右子树
		for (int i = root_index + 1; i < vin_len; i++) {
			vin_right.push_back(vin[i]);
			pre_right.push_back(pre[i]);
		}
		root->left = reConstructBinaryTree(pre_left, vin_left);
		root->right = reConstructBinaryTree(pre_right, vin_right);
		return root;
	}

	vector<int> PrintFromTopToBottom(TreeNode* root) {
		TreeNode* fr;
		if (root == NULL) {
			return result;
		}
		que.push(root);
		while (!que.empty()) {
			fr = que.front();
			result.push_back(fr->val);
			if (fr->left != NULL) {
				que.push(fr->left);
			}
			if (fr->right != NULL) {
				que.push(fr->right);
			}
			que.pop();
		}
		return result;
	}
private:
	vector<int> result;
	queue<TreeNode*> que;

};

int main() {
	Solution s;
	int a[8] = { 1,2,4,7,3,5,6,8 };
	int b[8] = { 4,7,2,1,5,3,8,6 };
	vector<int> pre;
	pre.insert(pre.begin(), a, a + 8);
	vector<int> vin;
	vin.insert(vin.begin(), b, b + 8);
	TreeNode *root = s.reConstructBinaryTree(pre, vin);
	vector<int> result = s.PrintFromTopToBottom(root);
	vector<int>::iterator it;
	for (it = result.begin(); it != result.end(); ++it) {
		cout << *it << endl;
	}

	system("pause");
	return 0;
}

/*
*                   1
*                 *    *
*              2          3
*            *           *   *
*          4            5      6
*         *
*       8
*/
```

# 5. 用两个栈实现队列

```C++
/* 题目：用两个栈实现队列
* 题目描述
* 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
*/

#include<iostream>
#include<stack>
using namespace std;

class Solution
{
public:
	void push(int node) {
		stack1.push(node);
	}

	int pop() {
		int res = 0;
		if (stack2.size() > 0) {
			res = stack2.top();
			stack2.pop();
		}
		else if (stack1.size() > 0) {
			while (stack1.size() > 0) {
				stack2.push(stack1.top());
				stack1.pop();
			}
			res = stack2.top();
			stack2.pop();
		}
		return res;
	}

private:
	stack<int> stack1;
	stack<int> stack2;
};

int main() {
	Solution s;
	s.push(5);
	s.push(6);
	s.pop();
	system("pause");
	return 0;
}
```

# 6. 旋转数组的最小数字

```C++
/* 题目：旋转数组的最小数字
* 题目描述
* 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
* 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。
* 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
* NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
*/

#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
	int minNumberInRotateArray(vector<int> rotateArray) {
		int size = rotateArray.size();
		if (size == 0) {
			return 0;
		}
		int left = 0, right = size - 1;
		int mid = 0;
		while (rotateArray[left] >= rotateArray[right]) {
			if (right - left == 1) {
				mid = right;
				break;
			}
			mid = (left + right) / 2;
			if (rotateArray[left] == rotateArray[right] && rotateArray[left] == rotateArray[mid]) {
				return MinNumber(rotateArray, left, right);
			}
			if (rotateArray[mid] >= rotateArray[left]) {
				left = mid;
			}
			else {
				right = mid;
			}
		}
		return rotateArray[mid];
	}
private:
	int MinNumber(vector<int> &num, int left, int right) {
		int res = num[left];
		for (int i = left + 1; i < right; i++) {
			if (num[i] < res) {
				res = num[i];
			}
		}
		return res;
	}
};

int main() {
	Solution s;
	vector<int> num = { 4,5,6,7,1,2,3 };
	cout << s.minNumberInRotateArray(num) << endl;
	system("pause");
	return 0;
}
```

# 7. 斐波那契数列

```C++
/* 题目：斐波那契数列
* 题目描述
* 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
*/

#include<iostream>
using namespace std;

class Solution {
public:
	/*int Fibonacci(int n) {
	if (n < 0)
	return -1;
	else if (n == 0)
	return 0;
	else if (n == 1)
	return 1;
	else
	return Fibonacci(n - 1) + Fibonacci(n - 2);
	}*/ //递归时间消耗太大
	int Fibonacci(int n) {
		if (n < 0)
			return -1;
		else if (n == 0)
			return 0;
		else if (n == 1 || n == 2)
			return 1;
		else {
			int first = 1, second = 1, temp;
			for (int i = 2; i < n; i++) {
				temp = first + second;
				first = second;
				second = temp;
			}
			return temp;
		}
	}
};

int main() {
	Solution s;
	cout << s.Fibonacci(5) << endl;
	system("pause");
	return 0;
}
```

# 8. 跳台阶

```C++
/* 题目：跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
* 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 总跳法是f(n) = f(n-1) + f(n-2);
f(1) = 1; f(2) = 2; f(3) = 3;Fibonacci数列
*/

/* 
* 递归方法对时间和空间的消耗比较大。
*/

#include<iostream>
using namespace std;

class Solution {
public:
	int jumpFloor(int number) {
		/*if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			return jumpFloor(number - 1) + jumpFloor(number - 2);
		}*/
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if(number == 2){
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloor(5) << endl;
	system("pause");
	return 0;
}
```

# 9. 变态跳台阶

```C++
#include<iostream>
using namespace std;

/* 题目：变态跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 第一次跳是n级，那么剩下的是0个台阶，跳法是f(0);
总跳法是f(n) = f(n-1) + f(n-2) + ... + f(1) + f(0);
f(n - 1) = f(n - 2) + ... + f(0);
f(n) = f(n-1)+ f(n-1) = 2*f(n-1);
f(0) = 1;
f(1) = 1;
f(2) = 2;
*/

class Solution {
public:
	int jumpFloorII(int number) {
		if (number == 0 || number == 1) {
			return 1;
		}
		else if (number > 0) {
			int res = 1;
			for (int i = 2; i <= number; i++) {
				res = 2 * res;
			}
			return res;
		}
		else {
			return 0;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloorII(5) << endl;
	system("pause");
	return 0;
}
```

# 10. 矩形覆盖

```C++
#include<iostream>
using namespace std;

/* 题目：矩形覆盖
* 题目描述
* 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
* 请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
*/

/* 
1. 当n=1时，只有一种方法；
2. 当n=2时，有两种方法；
第一块横着放，f(n-2)种放法；
第一块竖着放，f(n-1)种放法。
f(n) = f(n-1) + f(n-2);
*/

class Solution {
public:
	int rectCover(int number) {
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}

	}
};

int main() {
	Solution s;
	cout << s.rectCover(4) << endl;
	system("pause");
	return 0;
}
```

# 11. 二进制中1的个数

```C++
#include<iostream>
using namespace std;

/* 题目：二进制中1的个数
* 题目描述
* 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
*/

/* 题解
* 一个整数：0，正数，负数
* 这个数转换为2进制表示
* 负数怎么转换为2进制表示呢？

*********
* 从n的2进制形式的最右边开始判断是不是1
* 该解法如果输入时负数会陷入死循环，因为负数右移时，在最高位补得是1,
* 本题最终目的是求1的个数，那么会有无数个1了。
**********
* 用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数
*/



class Solution {
public:
	int  NumberOf1(int n) {
		/*int count = 0;
		int flag = 1;
		while (flag != 0) {//停止条件 flag = 0，位数移动完毕
			if ((n & flag) != 0) {
				count++;				
			}
			flag = flag << 1;
		}
		return count;	*/
		int count = 0;
		while (n != 0) {
			count++;
			n = (n - 1) & n;
		}
		return count;
		
	}
};

int main() {
	Solution s;
	cout << s.NumberOf1(10) << endl;
	system("pause");
	return 0;
}
```

# 12. 数值的整数次方

```C++
#include<iostream>
using namespace std;

/* 题目：数值的整数次方
* 题目描述
* 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
* 考察点：代码的完整性
*/

/* 题解
* 底数base，指数exponent
* 指数为正，为0，为负三种情况
* 指数为正时,指数值为1时返回base，指数值大于1时的处理：
* 递归的方法，为偶数时，指数对半分；为奇数时，exponent/2，exponent/2+1

* 非递归方法，平方乘算法
*/

class Solution {
public:
	double Power(double base, int exponent) {
		/*if (exponent > 0) {
			if (exponent == 1) {
				return base;
			}
			else {
				if (exponent % 2 == 0) {
					return Power(base, exponent / 2) * Power(base, exponent / 2);
				}
				else {
					return Power(base, exponent / 2) * Power(base, exponent / 2 + 1);
				}
			}
		}
		else if (exponent == 0) {
			return 1;
		}
		else {
			return 1 / Power(base, 0 - exponent);
		}*/

		/*double res = 1, currentValue = base;
		int n = exponent;
		if (exponent > 0) {
			n = exponent;
		}
		else if (exponent < 0) {
			if (base == 0) {
				cout << "base cannot be zero!" << endl;
			}
			n = 0 - exponent;
		}
		else {
			return base;
		}
		while (n != 0) {
			if ((n & 1) != 0) {
				res *= currentValue;
			}
			currentValue *= currentValue;
			n >>= 1;
		}
		return res = exponent >= 0 ? res : (1 / res);*/
		return pow(base,exponent);
	}
};

int main() {
	Solution s;
	cout << s.Power(10,2) << endl;
	system("pause");
	return 0;
}
```

# 13. 调整数组顺序使奇数位于偶数前面

```C++
#include<iostream>
#include<vector>
using namespace std;

/* 题目：调整数组顺序使奇数位于偶数前面
* 题目描述
* 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
* 使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
* 并保证奇数和奇数，偶数和偶数之间的相对位置不变。
*/

/* 题解
* 空间换取时间
****************************
* 或者可以采取另外一种插排的方式
* 将偶数删除再添加到最后，erase
*/

class Solution {
public:
	void reOrderArray(vector<int> &array) {
		int size = (int)array.size();//返回size_t类型,int强制转换一下
		if (size == 0) {
			return ;
		}
		vector<int> oddArray;
		vector<int> evenArray;
		for (int i = 0; i < size; i++) {
			if (array[i] % 2 == 1) {
				oddArray.push_back(array[i]);
			}
			else {
				evenArray.push_back(array[i]);
			}
		}
		for (int i = 0; i < size; i++) {
			array.pop_back();
		}
		for (int i = 0; i < (int)oddArray.size(); i++) {
			array.push_back(oddArray[i]);
		}
		for (int i = 0; i < (int)evenArray.size(); i++) {
			array.push_back(evenArray[i]);
		}

		/*for (int i = 0; i < size; i++) {
			cout << array[i] << endl;
		}*/
	}
};
int main() {
	Solution s;
	vector<int> num = { 1,2,3,4,5,6 };
	s.reOrderArray(num);
	system("pause");
	return 0;
}
```

# 14. 链表中倒数第k个结点

[常见链表操作](https://github.com/selfconzrr/LinkedList_learning)

```C++
#include<iostream>
using namespace std;

/* 题目：链表中倒数第k个结点
* 题目描述
* 输入一个链表，输出该链表中倒数第k个结点。
*/

/* 题解
* 我的思路：遍历统计链表中结点的个数，然后根据个数再从前往后找所要寻找的结点
* 大神思路：两个指针，制造一个K长度的尺子，把尺子从头往后移动，
* 当尺子的右端与链表的末尾对齐的时候，尺子的左端所在的结点就是倒数第k个结点。
* 优点：遍历次数减少，刚好遍历k个，相对于全部遍历再加一部分遍历优化很多。
*/

/*
* 双指针定位
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

/*class Solution {
public:
	ListNode * FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL) {
			return NULL;
		}
		ListNode *res = pListHead;
		ListNode *tmp = pListHead;
		unsigned int n = 0;
		while (tmp != NULL) {
			n++;
			tmp = tmp->next;
		}
		if (k > n) {
			return NULL;
		}
		for (unsigned int i = 1; i < n - k + 1;i++) {
			res = res->next;
		}
		return res;
	}
};*/

class Solution {
public:
	ListNode * FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL) 
			return pListHead;
		if (k == 0) 
			return NULL;
		ListNode* kth = NULL, *end = pListHead;
		int count = 1;
		while (end != NULL) {
			if (count++ == k) {
				kth = pListHead;
			}
			else if (count>k) {
				kth = kth->next;
			}
			end = end->next;
		}
		return kth;
	}
};

int main() {
	Solution s;
	ListNode *res = NULL;
	s.FindKthToTail(res,2);
	system("pause");
	return 0;
}
```

# 15. 反转链表

```C++
#include<iostream>
#include<stack>
using namespace std;

/* 题目：反转链表
* 题目描述
* 输入一个链表，反转链表后，输出新链表的表头。
*/

/* 题解
* 利用stack进行链表反转，将原来链表依次压入栈，然后取出。
* 3个指针
* 递归
*/

/*链表初始化
* 要改变一下关于链表的思考方向。
* 即：
* 1、不要用初始化数组或结构的方式去处理链表；
* 2、链表的每一个节点要用一个子程序进行动态创建，同时赋值；
* 3、删除链表中的节点时，要注意回收内存；
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

class Solution {
public:
	/*ListNode * ReverseList(ListNode* pHead) {		
 		if (pHead == NULL || pHead->next == NULL) {
			return pHead;
		}
		stack<ListNode *> s;
		ListNode *p = pHead;
		while (p->next != NULL) {
			s.push(p);
			p = p->next;
		}
		ListNode *head = p;
		while (!s.empty()) {			
			p->next = s.top();						
			p = p->next;
			s.pop();
		}
		p->next = NULL;
		return head;
	}*/
	ListNode* ReverseList(ListNode* pHead) {

		if (pHead == NULL) {
			return pHead;
		}
		ListNode* pre = NULL;
		ListNode* cur = pHead;
		ListNode* nxt = NULL;
		while (cur != NULL) {
			nxt = cur->next;
			cur->next = pre;
			if (nxt == NULL) {
				break;
			}
			pre = cur;
			cur = nxt;
		}
		return cur;
	}
};

/*class Solution {
public:
	ListNode * ReverseList(ListNode* pHead) {
		//如果链表为空或者链表中只有一个元素
		if (pHead == NULL || pHead->next == NULL) return pHead;

		//先反转后面的链表，走到链表的末端结点
		ListNode* pReverseNode = ReverseList(pHead->next);

		//再将当前节点设置为后面节点的后续节点
		pHead->next->next = pHead;
		pHead->next = NULL;

		return pReverseNode;

	}
};*/

//尾插法建立单链表
ListNode * Creat_LinkList_R()
{
	int x;
	ListNode *head, *p, *tail;                    //tail是尾指针
	head = (ListNode*)malloc(sizeof(ListNode));
	if (head == NULL)
		return head;
	head->next = NULL;
	tail = head;                                  //一开始尾指针指向头指针的位置
	cout << "请输入要录入的数以0结束" << endl;
	cin >> x;
	head->val = x;
	while ((cin>>x) && (x != 0))
	{
		p = (ListNode*)malloc(sizeof(ListNode));
		if (p == NULL)
			return head;
		p->val = x;
		tail->next = p;                          //将p插入到尾节点的后面
		tail = p;                                //修改尾节点的指向
		tail->next = NULL;                       //将尾节点的指针域修改为空
	}
	return head;
}


int main() {
	Solution s;
	ListNode * res, *newList;
	res = Creat_LinkList_R();

	/*while (res != NULL) {		
		cout << res->val << endl;	
		res = res->next;
	}*/

	newList = s.ReverseList(res);

	while (newList != NULL) {
		cout << newList->val << endl;
		newList = newList->next;
	}

	system("pause");
	return 0;
}
```

# 16. 合并两个排序的链表
```C++
#include<iostream>
#include<stack>
using namespace std;

/* 题目：合并两个排序的链表
* 题目描述
* 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
*/

/* 题解
* 1. 非递归方法，依次比较，O(N)的时间复杂度
* 2. 递归方法
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

class Solution {
public:
	ListNode * Merge(ListNode* pHead1, ListNode* pHead2)
	{
		if (pHead1 == NULL) {
			return pHead2;
		}
		else if(pHead2 == NULL){
			return pHead1;
		}
		else {
			ListNode * newList;
			if (pHead1->val <= pHead2->val) {
				newList = pHead1;
				newList->next = Merge(pHead1->next,pHead2);
			}
			else {
				newList = pHead2;
				newList->next = Merge(pHead1, pHead2->next);
			}
			return newList;
		}
	}
};


//尾插法建立单链表
ListNode * Creat_LinkList_R()
{
	int x;
	ListNode *head, *p, *tail;                    //tail是尾指针
	head = (ListNode*)malloc(sizeof(ListNode));
	if (head == NULL)
		return head;
	head->next = NULL;
	tail = head;                                  //一开始尾指针指向头指针的位置
	cout << "请输入要录入的数以0结束" << endl;
	cin >> x;
	head->val = x;
	while ((cin >> x) && (x != 0))
	{
		p = (ListNode*)malloc(sizeof(ListNode));
		if (p == NULL)
			return head;
		p->val = x;
		tail->next = p;                          //将p插入到尾节点的后面
		tail = p;                                //修改尾节点的指向
		tail->next = NULL;                       //将尾节点的指针域修改为空
	}
	return head;
}

int main() {
	Solution s;
	ListNode *list1, *list2, *newList;
	list1 = Creat_LinkList_R();
	list2 = Creat_LinkList_R();

	/*while (res != NULL) {
	cout << res->val << endl;
	res = res->next;
	}*/

	newList = s.Merge(list1, list2);

	while (newList != NULL) {
		cout << newList->val << endl;
		newList = newList->next;
	}

	system("pause");
	return 0;
}


```

# 17. 树的子结构

```C++
#include<iostream>
#include<queue>
using namespace std;

/* 题目：树的子结构
* 题目描述
* 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
*/

/* 题解
* 递归
*/


struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
	bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
	{
		if (!pRoot1)
			return false;
		if (!pRoot2)
			return false;
		return ( doesTree1HasTree2(pRoot1, pRoot2) || HasSubtree(pRoot1->left, pRoot2) || HasSubtree(pRoot1->right, pRoot2) );
	}
	bool doesTree1HasTree2(TreeNode* tree1, TreeNode* tree2) {
		if (!tree2) //tree2判断在前
			return true;
		if (!tree1)
			return false;
		if (tree1->val != tree2->val)
			return false;
		return (doesTree1HasTree2(tree1->left, tree2->left) && doesTree1HasTree2(tree1->right, tree2->right) );//这儿不应该递归调用HasSubtree
	}
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

int main() {
	Solution s;
	int nums[] = { 8,8,7,9,2,0,0,0,0,4,7};
	TreeNode *tree1 = initBTree(nums, 11);
	int nums2[] = { 8,9,2};
	TreeNode *tree2 = initBTree(nums2, 3);
	cout << s.HasSubtree(tree1, tree2) << endl;
	system("pause");
	return 0;
}
```

# 18. 二叉树的镜像

```C++
#include<iostream>
#include<queue>
using namespace std;

/* 题目：二叉树的镜像
* 题目描述
* 操作给定的二叉树，将其变换为源二叉树的镜像。
*/

/* 题解
* 递归
*/


struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};


class Solution {
public:
	void Mirror(TreeNode *pRoot) {
		if (!pRoot)
			return ;
		TreeNode * tmp;
		tmp = pRoot->right;
		pRoot->right = pRoot->left;
		pRoot->left = tmp;
		Mirror(pRoot->left);
		Mirror(pRoot->right);
	}
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

void preOrder(TreeNode *root, vector<int> &result)
{
	if (root)
	{
		result.push_back(root->val);
		preOrder(root->left, result);
		preOrder(root->right, result);
	}
}

void traverse(vector<int> nums)
{
	vector<int>::size_type size = nums.size();
	for (size_t i = 0; i < size; i++)
	{
		cout << nums[i] << ' ';
	}
	cout << endl;
}

int main() {
	Solution s;
	vector<int> preResult;
	vector<int> preResult2;
	int nums[] = { 8,6,10,5,7,9,11};
	TreeNode *tree1 = initBTree(nums, 7);
	preOrder(tree1, preResult);
	cout << "前序遍历的结果：" << '\n';
	traverse(preResult);
	s.Mirror(tree1);
	preOrder(tree1, preResult2);
	cout << "镜像的结果：" << '\n';
	traverse(preResult2);
	system("pause");
	return 0;
}
```

# 19. 顺时针打印矩阵

```C++
#include<iostream>
#include<vector>
using namespace std;

/* 题目：顺时针打印矩阵
* 题目描述
* 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
* 例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 
* 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
*/

/* 题解
* 设置左右上下四个标识符，每一圈标识符改变
*/

class Solution {
public:
	vector<int> printMatrix(vector<vector<int> > matrix) {
		vector<int> res;
		int size_row = (int)matrix.size();
		int size_col = (int)matrix[0].size();
		int left = 0, right = size_col - 1, top = 0, btm = size_row - 1;
		while (left <= right && top <= btm) {
			for (int i = left; i <= right; i++) {
				res.push_back(matrix[top][i]);
			}
			if (top < btm) {
				for (int i = top + 1; i <= btm; i++) {
					res.push_back(matrix[i][right]);
				}
			}
			if (left < right && top < btm ) {
				for (int i = right - 1; i >= left; i--) {
					res.push_back(matrix[btm][i]);
				}
			}
			if (top < btm && left < right) {
				for (int i = btm - 1; i > top; i--) {
					res.push_back(matrix[i][left]);
				}
			}
			left++; right--; top++; btm--;
		}
		int size = res.size();
		for (int i = 0; i < size; i++) {
			cout << res[i] << " ";
		}
		cout << endl;
		return res;
	}
};

int main() {
	Solution s;
	vector<vector<int> > matirx(1);
	int num = 1;
	for (int i = 0; i < matirx.size(); ++i) {
		for (int j = 0; j < 5; ++j) {
			matirx[i].push_back(num);
			num++;
			cout << matirx[i][j] << " ";
		}
	}
	cout << endl;
	s.printMatrix(matirx);
	system("pause");
	return 0;
}
```

# 20. 包含min函数的栈

```C++
#include<iostream>
#include<stack>
using namespace std;

/* 题目：包含min函数的栈
* 题目描述
* 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
*/

/* 题解
*/

class Solution {
public:
	void push(int value) {
		stack_in.push(value);
		if (stack_min.empty()) {
			stack_min.push(value);
		}
		if (stack_min.top() >= value) {
			stack_min.push(value);
		}
	}
	void pop() {		
		if (stack_in.top() == stack_min.top()) {
			stack_min.pop();
		}
		stack_in.pop();
		
	}
	int top() {
		return stack_in.top();
	}
	int min() {
		return stack_min.top();
	}
private:
	stack<int> stack_in;
	stack<int> stack_min;
};

int main() {
	Solution s;
	int num = 10;
	for (int i = 5; i < 10; i++) {
		s.push(num);
		num++;
	}
	cout << s.top() << endl;
	system("pause");
	return 0;
}
```

# 21. 栈的压入、弹出序列

```C++
#include<iostream>
#include<vector>
#include<stack>
using namespace std;

/* 题目：栈的压入、弹出序列
* 题目描述
* 输入两个整数序列，第一个序列表示栈的压入顺序，
请判断第二个序列是否可能为该栈的弹出顺序。
假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，
序列4,5,3,2,1是该压栈序列对应的一个弹出序列，
但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
*/

/* 题解
* 引入一个入栈，判断入栈顶元素是否等于弹出序列第一个元素，不等于，按照入栈序列入栈，等于，弹出，判断下一个
*/

class Solution {
public:
	bool IsPopOrder(vector<int> pushV, vector<int> popV) {
		stack<int> stackIn;
		int id = 0;
		for (int i = 0; i < popV.size(); i++) {
			while (stackIn.empty() || stackIn.top() != popV[i]) {				
				if (id > pushV.size() - 1) {
					return false;
				}
				stackIn.push(pushV[id++]);
			}
			stackIn.pop();
		}
		if (stackIn.empty())
			return true;
		else 
			return false;
	}
};

int main() {
	Solution s;
	vector<int> v1 = { 1,2,3,4,5 };
	vector<int> v2 = { 4,5,3,1,2 };

	cout << s.IsPopOrder(v1, v2)<< endl;

	system("pause");
	return 0;
}
```

# 22. 从上往下打印二叉树

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/* 题目：从上往下打印二叉树
* 题目描述
* 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
*/

/* 题解
* 利用队列，首先处理根结点，保存根结点，左孩子结点，右孩子结点，然后弹出根结点，处理左孩子结点，依次入队列
*/

struct TreeNode { 
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	vector<int> PrintFromTopToBottom(TreeNode* root) {
		vector<int> res;
		queue<TreeNode*> q;
		TreeNode *node;
		if (root == NULL) {
			return res;
		}
		q.push(root);		
		while (!q.empty()) {
			node = q.front();
			res.push_back(node->val);
			if (node->left != NULL) {
				q.push(node->left);
			}
			if (node->right != NULL) {
				q.push(node->right);
			}
			q.pop();
		}
		return res;
	}
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

int main() {
	Solution s;
	vector<int> res;
	int nums[] = { 8,6,10,5,7,9,11 };
	TreeNode *tree = initBTree(nums, 7);
	res = s.PrintFromTopToBottom(tree);
	int size = (int)res.size();
	for (int i = 0; i < size; i++) {
		cout << res[i] << "";
	}
	cout << endl;
	system("pause");
	return 0;
}
```

# 23. 二叉搜索树的后序遍历序列

二叉树的遍历分为三种：前序、中序、后序，其中中序遍历最为重要。

A：根结点，B：左结点，C：右结点，前序遍历ABC（根结点，然后同级先左结点后右结点），中序遍历BAC（先左结点后根结点最后右结点），后序遍历顺序BCA（先左结点后右结点最后根结点）

中序遍历的重要性体现在排序上，很多排序都利用到了中序遍历。

后序遍历左子树，后序遍历右子树，访问根结点。

二叉搜索树，左子树的值小于根节点，根节点小于右子树的值。

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/* 题目：二叉搜索树的后序遍历序列
* 题目描述
* 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
* 如果是则输出Yes, 否则输出No。假设输入的数组的任意两个数字都互不相同。
*/

/* 题解
*/

struct TreeNode { 
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	bool VerifySquenceOfBST(vector<int> sequence) {
		int size = sequence.size();
		return bsf(sequence, 0, size - 1);
	}
	bool bsf(vector<int> sequence, int begin, int end) {
		if (sequence.empty() || begin > end) {
			return false;
		}
		int root = sequence.back();
		int loc = begin;
		for (; loc < end; loc++) {
			if (sequence[loc] > root) {
				break;
			}
		}
		for (int i = loc; i < end; i++) {
			if (sequence[i] < root) {
				return false;
			}
		}
		bool left = true, right = true;
		if (loc > begin) {
			left = bsf(sequence, begin, loc - 1);
		}
		if (end > loc) {
			right = bsf(sequence, loc, end - 1);
		}		
		return left && right;
	}
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

int main() {
	Solution s;
	vector<int> sequence = {1,1,3,2,2};
	cout << s.VerifySquenceOfBST(sequence)<<endl;
	system("pause");
	return 0;
}
```

# 24. 二叉树中和为某一值的路径

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/* 题目：二叉树中和为某一值的路径
* 题目描述
* 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
* 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
* (注意: 在返回值的list中，数组长度大的数组靠前)
*/

/* 题解
* 全局变量
*/

struct TreeNode { 
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	vector<vector<int> > FindPath(TreeNode* root, int expectNumber) {
		if (root == NULL) {
			return path;
		}
		list.push_back(root->val);
		expectNumber -= root->val;
		if (expectNumber == 0 && root->left == NULL && root->right == NULL) {
			path.push_back(list);
		}
		FindPath(root->left, expectNumber);
		FindPath(root->right, expectNumber);
		if (!list.empty()) {
			list.pop_back();
		}
		return path;
	}
private:
	vector<vector<int> > path;
	vector<int> list;
};

TreeNode* initBTree(int elements[], int size)
{
	if (size < 1)
	{
		return NULL;
	}
	//动态申请size大小的指针数组
	TreeNode **nodes = new TreeNode*[size];
	//将int数据转换为TreeNode节点
	for (int i = 0; i < size; i++)
	{
		if (elements[i] == 0)
		{
			nodes[i] = NULL;
		}
		else
		{
			nodes[i] = new TreeNode(elements[i]);
		}
	}
	queue<TreeNode*> nodeQueue;
	nodeQueue.push(nodes[0]);

	TreeNode *node;
	int index = 1;
	while (index < size)
	{
		node = nodeQueue.front();
		nodeQueue.pop();
		nodeQueue.push(nodes[index++]);
		node->left = nodeQueue.back();
		nodeQueue.push(nodes[index++]);
		node->right = nodeQueue.back();
	}
	return nodes[0];
}

int main() {
	Solution s;
	int num[] = { 1,3,1,1,1,3,3 };
	TreeNode* tree = initBTree(num, 7);
	vector<vector<int> > path = s.FindPath(tree, 5);
	for (int i = 0; i < (int)path.size(); i++) {
		for (int j = 0; j < (int)path[0].size(); j++) {
			cout << path[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
	system("pause");
	return 0;
}
```

# 25. 复制链表的复制

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/* 题目：复制链表的复制
* 题目描述
* 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），
* 返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
*/

/* 题解
* 重新创建一个链表的副本，《剑指Offer》
*/

struct RandomListNode {
	int label;
	struct RandomListNode *next, *random;
	RandomListNode(int x) :
		label(x), next(NULL), random(NULL) {
	}
};

class Solution {
public:
	RandomListNode * Clone(RandomListNode* pHead)
	{
		CloneNodes(pHead);
		ConnectRandomNodes(pHead);
		return ReconnectNodes(pHead);
		
	}
	//复制原始链表的任意结点N并创建新节点N'，再把N’链接到N的后面 A-A'-B-B'
	void CloneNodes(RandomListNode* pHead) {
		RandomListNode * pNode = pHead;
		while (pNode != NULL) {
			RandomListNode * pCloned = new RandomListNode(pNode->label);
			pCloned->label = pNode->label;
			pCloned->next = pNode->next;
			pCloned->random = NULL;
			pNode->next = pCloned;

			pNode = pCloned->next;
		}
	}
	//如果原始链表上的结点N的random指向S，则它对应复制结点N'指向S的下一个结点S’,A-A'-B-B'-S-S' A.random = S ,A'.random = S'
	void ConnectRandomNodes(RandomListNode* pHead) {
		RandomListNode * pNode = pHead;
		while (pNode != NULL) {
			RandomListNode * pCloned = pNode->next;
			if (pNode->random != NULL) {
				pCloned->random = pNode->random->next;
			}
			pNode = pCloned->next;
		}
	}
	//将长链表拆分成两个链表，A-B-S，A'-B'-S'
	RandomListNode* ReconnectNodes(RandomListNode* pHead) {
		RandomListNode* pNode = pHead;
		RandomListNode* pClonedHead = NULL;
		RandomListNode* pClonedNode = NULL;
		if (pNode != NULL) {
			pClonedHead = pClonedNode = pNode->next;
			pNode->next = pClonedNode->next;
			pNode = pNode->next;
		}
		while (pNode != NULL) {
			pClonedNode->next = pNode->next;//链表链起来
			pClonedNode = pClonedNode->next;
			pNode->next = pClonedNode->next;
			pNode = pNode->next;
		}
		return pClonedHead;
	}
};

int main() {
	Solution s;
	RandomListNode * head = NULL;
	s.Clone(head);
	system("pause");
	return 0;
}
```

# 26. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

题解：中序遍历二叉树的结点，根节点与其左子树最大的一个结点链接起来，同时与其右子树中最小的一个结点链接起来。按照中序遍历的顺序，当遍历转换到根节点时，此时左子树已经转换为一个排序的链表了，并且处在链表中的最后一个结点就是当前值最大的结点，将这个值与根结点链接起来，接着去转换右子树。

遍历和转换过程是一样的，所以采用递归的方法。
```C++
#include<iostream>
using namespace std;

struct  TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x): val(x), left(NULL), right(NULL) {
	}
};

class Solution {
public:
	TreeNode * Convert(TreeNode* pRootOfTree) {
		TreeNode *pLastNodeOfList = NULL;
		ConvertNode(pRootOfTree, &pLastNodeOfList);
		TreeNode *pHeadOfList = pLastNodeOfList;//返回头节点
		while (pHeadOfList != NULL && pHeadOfList->left != NULL) {
			pHeadOfList = pHeadOfList->left;
		}
		return pHeadOfList;
	}
	void ConvertNode(TreeNode* pNode, TreeNode** pLastNodeInList) {
		if (pNode == NULL)
			return;
		TreeNode *pCurrent = pNode;
		if (pCurrent->left != NULL)
			ConvertNode(pCurrent->left, pLastNodeInList);
		pCurrent->left = *pLastNodeInList;
		if (*pLastNodeInList != NULL) {//空指针不能指向别的
			(*pLastNodeInList)->right = pCurrent;
		}
		*pLastNodeInList = pCurrent;
		if (pCurrent->right != NULL)
			ConvertNode(pCurrent->right, pLastNodeInList);
	}
};

int main() {
	Solution s;
	TreeNode * head = NULL;
	s.Convert(head);
	system("pause");
	return 0;
}
```