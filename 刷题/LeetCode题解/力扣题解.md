<!-- GFM-TOC -->
* [1. Two Sum](#1-Two Sum)
<!-- GFM-TOC -->

# 1. Two Sum

给定一个整数数组，返回两个数之和等于target的数组索引。

我的思路：夹逼准则，先排序，然后首位寻找是否等于target的数。但是这样排序改变了原来数组的下标，先找到这两个数，然后返回下标。

唉

最简单的方法是穷举搜索，一个是x，另外一个是target-x；复杂度O(n^2)

优化方法：两次hash表操作，对在一维数组中查找target-x优化。

进一步优化：一次hash表操作，边建立hash表边返回。

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		vector<int> res;
		int size = nums.size();
		if (size <= 1) return res;
		vector<int> nums_sort(nums);
		sort(nums_sort.begin(), nums_sort.end());
		int i = 0, j = size - 1;
		while (i <= size - 1 && j >= i) {
			if (nums_sort[i] + nums_sort[j] == target) {
				break;
			}
			else if (nums_sort[i] + nums_sort[j] > target) {
				j--;
			}
			else {
				i++;
			}
		}

		for (int k = 0; k < size; k++) {
			if (nums[k] == nums_sort[i] || nums[k] == nums_sort[j])
				res.push_back(k);
		}		
		return res;
	}
};

int main() {
	Solution s;
	vector<int> nums = { 3,3 };
	vector<int> res;
	res = s.twoSum(nums, 6);
	for (auto i : res)
		cout << i << " ";
	cout << endl;
	system("pause");
	return 0;
}
```