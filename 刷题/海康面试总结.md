## 一面
1. 给定 `n*n` 矩阵，计算新的 `n*n` 矩阵，新矩阵的 `(i,j)` 是以原矩阵 `(i,j)` 为中心的 `m*m` 小矩阵的均值。`m`是奇数。
2. 堆排序求 `TopK` 。
3. 实现 `k-means`，`MapReduce`。

第一题：暴力搜索，O(n^2*m^2)。需要考虑边界条件，问面试官。代码是工具，思考解决问题的方式不正确。手生了。
```C++
#include<iostream>
#include<vector>
using namespace std;

//边界单独处理，非边界的话
class Solution {
public:
	vector<vector<float >> avgMatirx(vector<vector<float >> data, int m) {
		vector<vector<float >> res;
		int rows = data.size();
		int cols = data[0].size();
		
		float tmp = 0.0;
		vector<float> avg;
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				//限制小m矩阵处理的范围
				int top = (i - m / 2) >= 0 ? (i - m / 2) : 0;
				int btm = (i + m / 2) < cols ? (i + m / 2) : (cols - 1);
				int left = (j - m / 2) >= 0 ? (j - m / 2) : 0;
				int right = (j + m / 2) < rows ? (j + m / 2) : (rows - 1);

				for (int k = top; k <= btm; k++)
					for (int t = left; t <= right; t++)
						tmp = tmp + data[k][t];
				avg.push_back(tmp / (m*m));//这个究竟是(right - left + 1)*(btm - top + 1)
				tmp = 0;
			}
			res.push_back(avg);
			avg.clear();
		}		
		return res;
	}
};

int main() {
	Solution s;
	vector<vector<float> > array = { {1,2,3,4},{3,4,5,6},{5,6,7,8},{7,8,9,10}};
	for (int i = 0; i < array.size(); i++)
	{
		for (int j = 0; j < array[0].size(); j++)
		{
			cout << array[i][j] << " ";
		}
		cout << endl;
	}
	vector<vector<float> > res = s.avgMatirx(array,3);
	for (int i = 0; i < res.size(); i++)
	{
		for (int j = 0; j < res[0].size(); j++)
		{
			cout << res[i][j] << " ";
		}
		cout << endl;
	}
	system("pause");
	return 0;
}
```