## lambda函数
```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

int greater1(int firstVal, int secondVal) {
	return firstVal > secondVal ? true : false;
} //greater是保留字

void findSpecificValue(const std::vector<int>& vec, int specificValue) {
	auto iter = vec.begin();
	iter = find_if(iter, vec.end(), std::bind(greater1, std::placeholders::_1, specificValue));
	if (iter != vec.end()) {
		cout << "greater than" << specificValue << ":" << *iter << endl;
	}
}

int main() {
	vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };
	findSpecificValue(vec, 8); 
	system("pause");
	return 0;
}


```
修改为`lambda`形式，只能输出`9`
```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using namespace std;

bool greater(int firstVal, int secondVal) {
	return firstVal > secondVal ? true : false;
}

void findSpecificValue(const std::vector<int>& vec, int specificValue) {
	auto iter = vec.begin();
	while (iter != vec.end()) {
		iter = find_if(iter, vec.end(), [specificValue](const int &a) {return a > specificValue; });
		if (iter != vec.end()) {
			cout << "greater than" << specificValue << ":" << *iter << endl;
		}
		iter++;
	}
}

int main() {
	vector<int> vec{ 1,2,3,4,5,6,7,8,9,10 };
	findSpecificValue(vec, 8);
	system("pause");
	return 0;
}
```

## String构造函数
```C++

```

## 翻转字串

假定我们都知道非常高效的算法来检查一个单词是否为其他字符串的子串。请将这个算法编写成一个函数，给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成，要求只能调用一次检查子串的函数。

给定两个字符串`s1`,`s2`,请返回`bool`值代表`s2`是否由`s1`旋转而成。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。

```C++
//考点：str.find(substr)
class ReverseEqual {
public:
	bool checkReverseEqual(string s1, string s2) {
		// write code here
		int len1 = s1.size(), len2 = s2.size();
		if (len1 != len2) return false;
		if (len1 == 0 || len2 == 0) return false;
		string str = s1 + s1;
		if (str.find(s2) == -1) return false;
		else return true;
	}
};
```

## 二叉树平衡检查
二叉树平衡的定义：空树且左右子树的高度不超过1，并且左右子树的子树也是平衡二叉树。

```C++
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
using namespace std;

struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
		val(x), left(NULL), right(NULL) {}
};

class Balance {
public:
	int calhigh(TreeNode* root) {
		if (root == nullptr) return 0;
		return 1 + max(calhigh(root->right), calhigh(root->left));
	}
	bool isBalance(TreeNode* root) {
		// write code here
		if (root == nullptr) return true;
		int left = calhigh(root->left);
		int right = calhigh(root->right);
		bool flag = (abs(left - right) <= 1);
		return flag && isBalance(root->left) && isBalance(root->right);
	}
};
```