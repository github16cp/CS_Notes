<!-- GFM-TOC -->
* [1. 二维数组中的查找](#1.二维数组中的查找)
* [2. 替换空格](#2.替换空格)
* [3. 从尾到头打印链表](#3.从尾到头打印链表)
* [4. 重建二叉树](#4.重建二叉树)
* [5. 用两个栈实现队列](#5.用两个栈实现队列)
* [6. 旋转数组的最小数字](#6.旋转数组的最小数字)
* [7. 斐波那契数列](#7.斐波那契数列)
* [8. 跳台阶](#8.跳台阶)
* [9. 变态跳台阶](#9.变态跳台阶)
* [10. 矩形覆盖](#10.矩形覆盖)
* [11. 二进制中1的个数](#11.二进制中1的个数)
* [12. 数值的整数次方](#12.数值的整数次方)
* [13. 调整数组顺序使奇数位于偶数前面](#13.调整数组顺序使奇数位于偶数前面)
* [14. 链表中倒数第k个结点](#14.链表中倒数第k个结点)
* [15. 反转链表](#15.反转链表)
<!-- GFM-TOC -->

# 1.二维数组中的查找

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```C++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int row = (int)array.size();
        int col = (int)array[0].size();
        
        if(row == 0 || col == 0)
            return false;
        
        if(target < array[0][0] || target > array[row-1][col-1])
            return false;
        
        for(int i=0;i<row;i++){
            int l = 0,r = col - 1,m;
            while(l <= r){
                m = (l+r)/2;
                if(target == array[i][m])
                    return true;
                else if(target < array[i][m])
                    r = m - 1;
                else
                    l = m + 1;
            }
        }
        
        return false;
    }
};
```

# 2.替换空格

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

```C++
class Solution {
public:
	void replaceSpace(char *str, int length) {
		int count = 0;
		for (int i = 0; i < length; i++) {
			if (str[i] == ' ')
				count++;
		}

		for (int i = length - 1; i >= 0; i--) {
			if (str[i] != ' ') {
				str[i + 2*count] = str[i];
			}
			else {
				count--;
				str[i + 2*count] = '%';
				str[i + 2 * count + 1] = '2';
				str[i + 2 * count + 2] = '0';
			}
		}
	}
};
```

# 3.从尾到头打印链表

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

```C++
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
	vector<int> printListFromTailToHead(ListNode* head) {
		vector<int> list;
		if (head != NULL) {
			list.insert(list.begin(), head->val);
			if (head->next != NULL) {
				vector<int> tempVal = printListFromTailToHead(head->next);
				if (tempVal.size() > 0)
					list.insert(list.begin(), tempVal.begin(), tempVal.end());
			}
		}
		return list;
	}
};
```

# 4.重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

```C++
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

/**
* Definition for binary tree */
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
	TreeNode * reConstructBinaryTree(vector<int> pre, vector<int> vin) {
		int vin_len = vin.size();
		if (vin_len == 0)
			return NULL;

		vector<int> pre_left, pre_right, vin_left, vin_right;

		TreeNode *root = new TreeNode(pre[0]);

		int root_index = 0;
		for (int i = 0; i < vin_len; i++) {
			if (vin[i] == root->val) {
				root_index = i;
				break;
			}
		}
		//构建左子树
		for (int i = 0; i < root_index; i++) {
			vin_left.push_back(vin[i]);
			pre_left.push_back(pre[i + 1]);
		}
		//构建右子树
		for (int i = root_index + 1; i < vin_len; i++) {
			vin_right.push_back(vin[i]);
			pre_right.push_back(pre[i]);
		}
		root->left = reConstructBinaryTree(pre_left, vin_left);
		root->right = reConstructBinaryTree(pre_right, vin_right);
		return root;
	}

	vector<int> PrintFromTopToBottom(TreeNode* root) {
		TreeNode* fr;
		if (root == NULL) {
			return result;
		}
		que.push(root);
		while (!que.empty()) {
			fr = que.front();
			result.push_back(fr->val);
			if (fr->left != NULL) {
				que.push(fr->left);
			}
			if (fr->right != NULL) {
				que.push(fr->right);
			}
			que.pop();
		}
		return result;
	}
private:
	vector<int> result;
	queue<TreeNode*> que;

};

int main() {
	Solution s;
	int a[8] = { 1,2,4,7,3,5,6,8 };
	int b[8] = { 4,7,2,1,5,3,8,6 };
	vector<int> pre;
	pre.insert(pre.begin(), a, a + 8);
	vector<int> vin;
	vin.insert(vin.begin(), b, b + 8);
	TreeNode *root = s.reConstructBinaryTree(pre, vin);
	vector<int> result = s.PrintFromTopToBottom(root);
	vector<int>::iterator it;
	for (it = result.begin(); it != result.end(); ++it) {
		cout << *it << endl;
	}

	system("pause");
	return 0;
}

/*
*                   1
*                 *    *
*              2          3
*            *           *   *
*          4            5      6
*         *
*       8
*/
```

# 5.用两个栈实现队列

```C++
/* 题目：用两个栈实现队列
* 题目描述
* 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
*/

#include<iostream>
#include<stack>
using namespace std;

class Solution
{
public:
	void push(int node) {
		stack1.push(node);
	}

	int pop() {
		int res = 0;
		if (stack2.size() > 0) {
			res = stack2.top();
			stack2.pop();
		}
		else if (stack1.size() > 0) {
			while (stack1.size() > 0) {
				stack2.push(stack1.top());
				stack1.pop();
			}
			res = stack2.top();
			stack2.pop();
		}
		return res;
	}

private:
	stack<int> stack1;
	stack<int> stack2;
};

int main() {
	Solution s;
	s.push(5);
	s.push(6);
	s.pop();
	system("pause");
	return 0;
}
```

# 6.旋转数组的最小数字

```C++
/* 题目：旋转数组的最小数字
* 题目描述
* 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
* 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。
* 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
* NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
*/

#include<iostream>
#include<vector>
using namespace std;

class Solution {
public:
	int minNumberInRotateArray(vector<int> rotateArray) {
		int size = rotateArray.size();
		if (size == 0) {
			return 0;
		}
		int left = 0, right = size - 1;
		int mid = 0;
		while (rotateArray[left] >= rotateArray[right]) {
			if (right - left == 1) {
				mid = right;
				break;
			}
			mid = (left + right) / 2;
			if (rotateArray[left] == rotateArray[right] && rotateArray[left] == rotateArray[mid]) {
				return MinNumber(rotateArray, left, right);
			}
			if (rotateArray[mid] >= rotateArray[left]) {
				left = mid;
			}
			else {
				right = mid;
			}
		}
		return rotateArray[mid];
	}
private:
	int MinNumber(vector<int> &num, int left, int right) {
		int res = num[left];
		for (int i = left + 1; i < right; i++) {
			if (num[i] < res) {
				res = num[i];
			}
		}
		return res;
	}
};

int main() {
	Solution s;
	vector<int> num = { 4,5,6,7,1,2,3 };
	cout << s.minNumberInRotateArray(num) << endl;
	system("pause");
	return 0;
}
```

# 7.斐波那契数列

```C++
/* 题目：斐波那契数列
* 题目描述
* 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
*/

#include<iostream>
using namespace std;

class Solution {
public:
	/*int Fibonacci(int n) {
	if (n < 0)
	return -1;
	else if (n == 0)
	return 0;
	else if (n == 1)
	return 1;
	else
	return Fibonacci(n - 1) + Fibonacci(n - 2);
	}*/ //递归时间消耗太大
	int Fibonacci(int n) {
		if (n < 0)
			return -1;
		else if (n == 0)
			return 0;
		else if (n == 1 || n == 2)
			return 1;
		else {
			int first = 1, second = 1, temp;
			for (int i = 2; i < n; i++) {
				temp = first + second;
				first = second;
				second = temp;
			}
			return temp;
		}
	}
};

int main() {
	Solution s;
	cout << s.Fibonacci(5) << endl;
	system("pause");
	return 0;
}
```

# 8.跳台阶

```C++
/* 题目：跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
* 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 总跳法是f(n) = f(n-1) + f(n-2);
f(1) = 1; f(2) = 2; f(3) = 3;Fibonacci数列
*/

/* 
* 递归方法对时间和空间的消耗比较大。
*/

#include<iostream>
using namespace std;

class Solution {
public:
	int jumpFloor(int number) {
		/*if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			return jumpFloor(number - 1) + jumpFloor(number - 2);
		}*/
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if(number == 2){
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloor(5) << endl;
	system("pause");
	return 0;
}
```

# 9.变态跳台阶

```C++
#include<iostream>
using namespace std;

/* 题目：变态跳台阶
* 题目描述
* 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
*/

/* 两种跳法:
1. 第一次跳是1级，那么剩下的是n-1个台阶，跳法是f(n-1);
2. 第一次跳是2级，那么剩下的是n-2个台阶，跳法是f(n-2);
3. 第一次跳是n级，那么剩下的是0个台阶，跳法是f(0);
总跳法是f(n) = f(n-1) + f(n-2) + ... + f(1) + f(0);
f(n - 1) = f(n - 2) + ... + f(0);
f(n) = f(n-1)+ f(n-1) = 2*f(n-1);
f(0) = 1;
f(1) = 1;
f(2) = 2;
*/

class Solution {
public:
	int jumpFloorII(int number) {
		if (number == 0 || number == 1) {
			return 1;
		}
		else if (number > 0) {
			int res = 1;
			for (int i = 2; i <= number; i++) {
				res = 2 * res;
			}
			return res;
		}
		else {
			return 0;
		}
	}
};

int main() {
	Solution s;
	cout << s.jumpFloorII(5) << endl;
	system("pause");
	return 0;
}
```

# 10.矩形覆盖

```C++
#include<iostream>
using namespace std;

/* 题目：矩形覆盖
* 题目描述
* 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
* 请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
*/

/* 
1. 当n=1时，只有一种方法；
2. 当n=2时，有两种方法；
第一块横着放，f(n-2)种放法；
第一块竖着放，f(n-1)种放法。
f(n) = f(n-1) + f(n-2);
*/

class Solution {
public:
	int rectCover(int number) {
		if (number < 1) {
			return 0;
		}
		else if (number == 1) {
			return 1;
		}
		else if (number == 2) {
			return 2;
		}
		else {
			int first = 1, second = 2, third;
			for (int i = 3; i <= number; i++) {
				third = first + second;
				first = second;
				second = third;
			}
			return third;
		}

	}
};

int main() {
	Solution s;
	cout << s.rectCover(4) << endl;
	system("pause");
	return 0;
}
```

# 11.二进制中1的个数

```C++
#include<iostream>
using namespace std;

/* 题目：二进制中1的个数
* 题目描述
* 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
*/

/* 题解
* 一个整数：0，正数，负数
* 这个数转换为2进制表示
* 负数怎么转换为2进制表示呢？

*********
* 从n的2进制形式的最右边开始判断是不是1
* 该解法如果输入时负数会陷入死循环，因为负数右移时，在最高位补得是1,
* 本题最终目的是求1的个数，那么会有无数个1了。
**********
* 用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数
*/



class Solution {
public:
	int  NumberOf1(int n) {
		/*int count = 0;
		int flag = 1;
		while (flag != 0) {//停止条件 flag = 0，位数移动完毕
			if ((n & flag) != 0) {
				count++;				
			}
			flag = flag << 1;
		}
		return count;	*/
		int count = 0;
		while (n != 0) {
			count++;
			n = (n - 1) & n;
		}
		return count;
		
	}
};

int main() {
	Solution s;
	cout << s.NumberOf1(10) << endl;
	system("pause");
	return 0;
}
```

# 12.数值的整数次方

```C++
#include<iostream>
using namespace std;

/* 题目：数值的整数次方
* 题目描述
* 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
* 考察点：代码的完整性
*/

/* 题解
* 底数base，指数exponent
* 指数为正，为0，为负三种情况
* 指数为正时,指数值为1时返回base，指数值大于1时的处理：
* 递归的方法，为偶数时，指数对半分；为奇数时，exponent/2，exponent/2+1

* 非递归方法，平方乘算法
*/

class Solution {
public:
	double Power(double base, int exponent) {
		/*if (exponent > 0) {
			if (exponent == 1) {
				return base;
			}
			else {
				if (exponent % 2 == 0) {
					return Power(base, exponent / 2) * Power(base, exponent / 2);
				}
				else {
					return Power(base, exponent / 2) * Power(base, exponent / 2 + 1);
				}
			}
		}
		else if (exponent == 0) {
			return 1;
		}
		else {
			return 1 / Power(base, 0 - exponent);
		}*/

		/*double res = 1, currentValue = base;
		int n = exponent;
		if (exponent > 0) {
			n = exponent;
		}
		else if (exponent < 0) {
			if (base == 0) {
				cout << "base cannot be zero!" << endl;
			}
			n = 0 - exponent;
		}
		else {
			return base;
		}
		while (n != 0) {
			if ((n & 1) != 0) {
				res *= currentValue;
			}
			currentValue *= currentValue;
			n >>= 1;
		}
		return res = exponent >= 0 ? res : (1 / res);*/
		return pow(base,exponent);
	}
};

int main() {
	Solution s;
	cout << s.Power(10,2) << endl;
	system("pause");
	return 0;
}
```

# 13.调整数组顺序使奇数位于偶数前面

```C++
#include<iostream>
#include<vector>
using namespace std;

/* 题目：调整数组顺序使奇数位于偶数前面
* 题目描述
* 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
* 使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，
* 并保证奇数和奇数，偶数和偶数之间的相对位置不变。
*/

/* 题解
* 空间换取时间
****************************
* 或者可以采取另外一种插排的方式
* 将偶数删除再添加到最后，erase
*/

class Solution {
public:
	void reOrderArray(vector<int> &array) {
		int size = (int)array.size();//返回size_t类型,int强制转换一下
		if (size == 0) {
			return ;
		}
		vector<int> oddArray;
		vector<int> evenArray;
		for (int i = 0; i < size; i++) {
			if (array[i] % 2 == 1) {
				oddArray.push_back(array[i]);
			}
			else {
				evenArray.push_back(array[i]);
			}
		}
		for (int i = 0; i < size; i++) {
			array.pop_back();
		}
		for (int i = 0; i < (int)oddArray.size(); i++) {
			array.push_back(oddArray[i]);
		}
		for (int i = 0; i < (int)evenArray.size(); i++) {
			array.push_back(evenArray[i]);
		}

		/*for (int i = 0; i < size; i++) {
			cout << array[i] << endl;
		}*/
	}
};
int main() {
	Solution s;
	vector<int> num = { 1,2,3,4,5,6 };
	s.reOrderArray(num);
	system("pause");
	return 0;
}
```

# 14.链表中倒数第k个结点

[常见链表操作](https://github.com/selfconzrr/LinkedList_learning)

```C++
#include<iostream>
using namespace std;

/* 题目：链表中倒数第k个结点
* 题目描述
* 输入一个链表，输出该链表中倒数第k个结点。
*/

/* 题解
* 我的思路：遍历统计链表中结点的个数，然后根据个数再从前往后找所要寻找的结点
* 大神思路：两个指针，制造一个K长度的尺子，把尺子从头往后移动，
* 当尺子的右端与链表的末尾对齐的时候，尺子的左端所在的结点就是倒数第k个结点。
* 优点：遍历次数减少，刚好遍历k个，相对于全部遍历再加一部分遍历优化很多。
*/

/*
* 双指针定位
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

/*class Solution {
public:
	ListNode * FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL) {
			return NULL;
		}
		ListNode *res = pListHead;
		ListNode *tmp = pListHead;
		unsigned int n = 0;
		while (tmp != NULL) {
			n++;
			tmp = tmp->next;
		}
		if (k > n) {
			return NULL;
		}
		for (unsigned int i = 1; i < n - k + 1;i++) {
			res = res->next;
		}
		return res;
	}
};*/

class Solution {
public:
	ListNode * FindKthToTail(ListNode* pListHead, unsigned int k) {
		if (pListHead == NULL) 
			return pListHead;
		if (k == 0) 
			return NULL;
		ListNode* kth = NULL, *end = pListHead;
		int count = 1;
		while (end != NULL) {
			if (count++ == k) {
				kth = pListHead;
			}
			else if (count>k) {
				kth = kth->next;
			}
			end = end->next;
		}
		return kth;
	}
};

int main() {
	Solution s;
	ListNode *res = NULL;
	s.FindKthToTail(res,2);
	system("pause");
	return 0;
}
```

# 15.反转链表

```C++
#include<iostream>
#include<stack>
using namespace std;

/* 题目：反转链表
* 题目描述
* 输入一个链表，反转链表后，输出新链表的表头。
*/

/* 题解
* 利用stack进行链表反转，将原来链表依次压入栈，然后取出。
* 3个指针
* 递归
*/

/*链表初始化
* 要改变一下关于链表的思考方向。
* 即：
* 1、不要用初始化数组或结构的方式去处理链表；
* 2、链表的每一个节点要用一个子程序进行动态创建，同时赋值；
* 3、删除链表中的节点时，要注意回收内存；
*/

struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :val(x), next(NULL) {}
};

class Solution {
public:
	/*ListNode * ReverseList(ListNode* pHead) {		
 		if (pHead == NULL || pHead->next == NULL) {
			return pHead;
		}
		stack<ListNode *> s;
		ListNode *p = pHead;
		while (p->next != NULL) {
			s.push(p);
			p = p->next;
		}
		ListNode *head = p;
		while (!s.empty()) {			
			p->next = s.top();						
			p = p->next;
			s.pop();
		}
		p->next = NULL;
		return head;
	}*/
	ListNode* ReverseList(ListNode* pHead) {

		if (pHead == NULL) {
			return pHead;
		}
		ListNode* pre = NULL;
		ListNode* cur = pHead;
		ListNode* nxt = NULL;
		while (cur != NULL) {
			nxt = cur->next;
			cur->next = pre;
			if (nxt == NULL) {
				break;
			}
			pre = cur;
			cur = nxt;
		}
		return cur;
	}
};

/*class Solution {
public:
	ListNode * ReverseList(ListNode* pHead) {
		//如果链表为空或者链表中只有一个元素
		if (pHead == NULL || pHead->next == NULL) return pHead;

		//先反转后面的链表，走到链表的末端结点
		ListNode* pReverseNode = ReverseList(pHead->next);

		//再将当前节点设置为后面节点的后续节点
		pHead->next->next = pHead;
		pHead->next = NULL;

		return pReverseNode;

	}
};*/

//尾插法建立单链表
ListNode * Creat_LinkList_R()
{
	int x;
	ListNode *head, *p, *tail;                    //tail是尾指针
	head = (ListNode*)malloc(sizeof(ListNode));
	if (head == NULL)
		return head;
	head->next = NULL;
	tail = head;                                  //一开始尾指针指向头指针的位置
	cout << "请输入要录入的数以0结束" << endl;
	cin >> x;
	head->val = x;
	while ((cin>>x) && (x != 0))
	{
		p = (ListNode*)malloc(sizeof(ListNode));
		if (p == NULL)
			return head;
		p->val = x;
		tail->next = p;                          //将p插入到尾节点的后面
		tail = p;                                //修改尾节点的指向
		tail->next = NULL;                       //将尾节点的指针域修改为空
	}
	return head;
}


int main() {
	Solution s;
	ListNode * res, *newList;
	res = Creat_LinkList_R();

	/*while (res != NULL) {		
		cout << res->val << endl;	
		res = res->next;
	}*/

	newList = s.ReverseList(res);

	while (newList != NULL) {
		cout << newList->val << endl;
		newList = newList->next;
	}

	system("pause");
	return 0;
}
```